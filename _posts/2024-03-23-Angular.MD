---
title: Angular
date: 2024-03-23 00:00:00 +0100
categories: [default]
tags: [angular, frontend] # TAG names should always be lowercase
---

## Beginning

1. To create Angular app, install Angular CLI and execute
    - `ng new my-app --no-strict --standalone false --routing false`
    - `--no-strict` will help learning by not using strict mode
    - `--standalone false` as `standalone` is some other way of working with Angular
    - `--routing false` as for the beginning routing is not needed
2. `<input type="text" [(ngModel)]="myVariable">`
    - Listen to everything that is inputted and save it in `myVariable`
    - At the same time listen to this variable and update `<input>` accordingly
    - Notice that `ngModel` is imported from `FormsModule`
        - `import { FormsModule } from '@angular/forms';`
3. You can use Bootstrap for out-of-the-box useful styles
    - `npm install --save bootstrap@3`
    - Then reach your CSS located in `node_modules/bootstrap/dist/css/bootstrap.min.css`
4. In `angular.json` you can specify style sources
    - Ordering matters, so latter ones will override former ones
    - Set it in `projects.first-app.architect.build.options.styles` property
5. `npm install` problems
    - When getting errors with `npm install`, a solution may be to run `npm install --legacy-peer-deps` instead of `npm install`.

### Testing

Running tests on WSL2 requires to handle Chrome executable.  
Therefore working with them is more straightforward on host system.

1. Run tests
    - Build app in watch mode, launch Karma test runner
    - `ng test`
2. Customize Karma test runner
    - Create `karma.conf.js`, update `angular.json`
    - `ng generate config karma`
3. Run tests in CI/CD
    - `ng test --no-watch --no-progress --browsers=ChromeHeadless`
4. Generate Coverage Report
    - `ng test --no-watch --code-coverage`
5. Some ways of injecting dependencies
    1. Just use real production service
        - `new SubjectUnderTest(new ProdService())`
    2. Use fake service
        - `new SubjectUnderTest(new FakeService())`
    3. Use fake object
        - `new SubjectUnderTest({ someFunction: () => 'fake value' } as ProdService)`
    4. Use Spy
        - ```js
          const serviceSpy = jasmine.createSpyObj("ProdService", [ 'someFunction' ]);
          const stubValue = "stub value";
          serviceSpy.someFunction.and.returnValue(stubValue);
          new SubjectUnderTest(serviceSpy);
          ```

#### `TestBed`

1. `TestBed` creates a dynamically-constructed Angular test module that emulates an Angular `@NgModule`.
2. `TestBed.configureTestingModule()` method takes a metadata object that can have most of the properties of an `@NgModule`.
3. When you want to test a Service, use `providers` metadata property and specify there other Services you want to mock.
    - `TestBed.configureTestingModule({ providers: [ MyService, { provide: OtherService, useValue: spy } ] });`
    - Or if using real class, instead of `useValue`, use: `useClass: TestOtherService`
4. Inject it then using `const service = TestBed.inject(MyService)`
5. Example

    - ```js
      let myService: MyService;
      let otherServiceSpy: jasmine.SpyObj<OtherService>;

      beforeEach(() => (
        const spy = jasmine.createSpyObj('OtherService', ['someFunction']);
        TestBed.configureTestingModule({ providers: [ MyService, { provide: OtherService, useValue: spy } ]});
      ));

      myService = TestBed.inject(MyService);
      otherServiceSpy = TestBed.inject(OtherService) as jasmine SpyObj<OtherService>;
      ```

#### Testing HTTP Services

1. ❗ Always provide both `next` and `error` callbacks for `Observable`s.  
   Otherwise you may encounter other tests failing in random places!
    - It is because without specifying `error`, you end up with an asynchronous uncaught observable error.
2. Example of HTTP test

    - ```js
      let httpClientSpy: jasmine.SpyObj<HttpClient>;
      let myService: MyService;

      beforeEach(() => {
        httpClientSpy = jasmine.createObjSpy('HttpClient', ['get']);
        myService = new MyService(httpClientSpy);
      });

      it('should return expected response', (done: DoneFn) => {
        const expectedValue = 'correct value';

        httpClientSpy.get.and.returnValue(asyncData(expectedValue));

        myService.someFunction().subscribe({
            next: (returnedValue) => {
                expect(returnedValue).toEqual(expectedValue);
                done();
            },
            error: done.fail,
        });
        expect(httpClientSpy.get.calls.count()).toBe(1);
      });
      ```

3. `HttpClientTestingModule`
    - Used for complex interactions
    - It's covered in [HttpGuide](https://angular.io/guide/http-test-requests)

#### Testing Components

1. Remember to manually call [lifecycle hook methods](https://angular.io/guide/lifecycle-hooks) like `ngOnInit` (just as Angular would do)

##### DOM Testing

1. Component is more than just a class. It interacts with DOM and other Components.
    - Therefore tests covering only a class won't tell if Component renders, interacts with user or interact with other (e.g. parent or child) Components properly.
    - You need to examine DOM and simulate user interactions to be able to confirm Component works as intended.
2. When function call is asynchronous, you can use `waitForAsync()`
    - ```js
      beforeEach(waitForAsync(() => {
        TestBed.configureTestingModule({ imports: [ BannerComponent ]}).compileComponents();
      }));
      ```
3. Basic Component test assertion
    - Component can be created
    - `expect(component).toBeDefined();`
4. `createComponent()`
    - `TestBed.createComponent(MyComponent)` creates an instance of `MyComponent`, adds it to the DOM and returns a `ComponentFixture`
5. `ComponentFixture`
    - It's a harness for interacting with the created Component and its corresponding element
    - ```js
      const componentFixture = TestBed.createComponent(MyComponent);
      const component = componentFixture.componentInstance;
      expect(component).toBeDefined();
      ```
6. ❗ Don't reconfigure `TestBed` after calling `createComponent()`
    - `createComponent()` freezes the current `TestBed` definition, which makes it closed to further modifications
7. `NativeElement`
    - It's `any` type, as at a compile time it's unknown what type it is or even if it's an `HTMLElement`
        - Tests may be run on a non-browser platform such as WebWorker or any other that doesn't have DOM or where DOM-emulation doesn't support full `HTMLElement` API
    - In standard browser environment `nativeElement` will always be an `HTMLElement` (or one of it's derived classes)
    - You can use standard HTML API then, e.g. `querySelector()`
        - ```js
          const bannerElement: HTMLElement = componentFixture.nativeElement;
          const paragraph = bannerElement.querySelector('p')!;
          expect(p.textContext).toEqual('Hello World');
          ```
    - Under the hood it's actually `fixture.debugElement.nativeElement`
8. `DebugElement`
    - An abstraction to work safely across all platforms
    - Angular creates a `DebugElement` tree which wraps `NativeElement`s for the running platform
    - `DebugElement` contains methods and properties useful in testing
9. Example of testing
