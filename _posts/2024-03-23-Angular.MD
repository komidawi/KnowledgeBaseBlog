---
title: Angular
date: 2024-03-23 00:00:00 +0100
categories: [default]
tags: [angular, frontend] # TAG names should always be lowercase
---

## Table of Contents

-   [Table of Contents](#table-of-contents)
-   [Inbox](#inbox)
-   [Angular](#angular)
    -   [Installation, initialization](#installation-initialization)
    -   [Selectors](#selectors)
    -   [Directives](#directives)
    -   [Binding](#binding)
-   [How it works](#how-it-works)
-   [Definitions](#definitions)
-   [Various](#various)
    -   [Various](#various-1)
    -   [Emmet](#emmet)
    -   [The rest](#the-rest)
-   [Bootstrap](#bootstrap)
-   [Testing](#testing)
    -   [`TestBed`](#testbed)
    -   [Testing HTTP Services](#testing-http-services)
    -   [Testing Components](#testing-components)
        -   [DOM Testing](#dom-testing)

## Inbox

## Angular

### Installation, initialization

1. To create Angular app, install Angular CLI and execute
    - `ng new my-app --no-strict --standalone false --routing false`
    - `--no-strict` at a beginning will help learning by not using strict mode
    - `--standalone false` as `standalone` is some other way of working with Angular
    - `--routing false` as for the beginning routing is not needed
2. In `angular.json` you can specify style sources
    - Ordering matters, so latter ones will override former ones
    - Set it in `projects.first-app.architect.build.options.styles` property
3. You can use Bootstrap for out-of-the-box useful styles
    - `npm install --save bootstrap@3`
    - Then reach your CSS located in `node_modules/bootstrap/dist/css/bootstrap.css`
    - You can use minified file, which is smaller: `bootstrap.min.css`
    - You add the style to `angular.json` in a way mentioned above
4. `npm install` problems
    - When getting errors with `npm install`, a solution may be to run `npm install --legacy-peer-deps` instead of `npm install`.
5. Create Component from CLI
    - `ng generate component my-component`
    - or in short: `ng g c my-component`
    - You can exclude creating tests with `--skip-tests`

### Selectors

1. Selector
    - It's the way Angular selects an element
2. Available Selectors
    1. **Element Selector**
        - Used for Components
        - `my-component` -> `<my-component></my-component>`
    2. **Attribute Selector**
        - `[my-component]` -> e.g. `<div my-component></div>`
    3. **Class Selector**
        - `.my-component` -> e.g. `<div class="my-component"></div>`
    4. **ID Selectors, PseudoSelectors** (like hover)
        - Not supported
3. Data Binding
    - It can be described as communication between:
        - Business Logic Layer (TypeScript)
        - Presentation Layer (HTML)
4. Data Binding possibilities
    1. **Output Data (from TS to HTML)**
        1. String Interpolation `{{ myValue }}`
        2. Property Binding - input: `[disabled]="userIsGuest"`, a: `[url]="recipe.url"`
    2. **React to (User) Events**
        - Event Binding `(event)="someExpression"`
    3. **Two-Way Data Binding**
        - `[(ngModel)]="data"`
5. `<input type="text" [(ngModel)]="myVariable">`
    - Listen to everything that is inputted and save it in `myVariable`
    - At the same time listen to this variable and update `<input>` text accordingly
    - Notice that `ngModel` is imported from `FormsModule`
        - `import { FormsModule } from '@angular/forms';`
6. `$event`
    - Syntax for data emitted by a given event
    - Like keystroke in input
        - `<input type="text" (input)="onKeystroke($event)">`

### Directives

1. Directives
    - Instructions in the DOM
    - Structural Directives
        - It means it changes the structure of the DOM
        - It doesn't hide/unhide, it really adds/removes elements
        - It can be only one Structural Directive on an element
        - Structural Directives start with a star `*`
        - Example: `*ngIf`, `*ngFor`
    - Attribute Directives
        - They allow to manipulate attributes
        - They change only the element they sit on
        - Example: `ngStyle`
2. Create `*ngIf` with `else`
    - Create `*ngIf` element
        - `<p *ngIf="myPredicate"; else myReference>Predicate is satisfied</p>`
    - Create a local reference in an "else" element
        - `<ng-template #myReference><p>Predicate not satisfied</p></ng-template>`
3. `*ngFor`
    - Get index of current iteration
        - `*ngFor="let item of items; let i = index"`
4. Custom Directives

    - Example
        1. Write code
            - ```js
              @Directive({
                  selector: '[appHighlight]'
              })
              export class HighlightDirective implements OnInit {
                  constructor(private elementRef: ElementRef, private renderer: Renderer2) { }
                  ngOnInit() {
                          this.renderer.setStyle(this.elementRef.nativeElement, 'background-color', 'yellow');
                  }
              }
              ```
        2. Add Directive to `@NgModule` `declarations`:
            - ```js
              @NgModule({
                  declarations: [
                      AppComponent,
                      HighlightDirective
                  ]
              })
              ```
    - Generate

        - `ng generate directive improved-highlight`
        - `ng g d improved-highlight`

    - Directives allow to listen to events:
        - ```js
          @HostListener('mouseenter') mouseenter(event: Event) {
              this.renderer.setStyle(this.elementRef.nativeElement, 'background-color', 'blue')
          }
          ```

    5. Structural Directives behind the scenes
        - Something like this
            - ```xml
              <div *ngIf="x > 0">
                  <p>x is greater than 0</p>
              </div>
              ```
        - Gets translated into:
            - ```xml
              <ng-template [ngIf]="x > 0">
                  <div>
                      <p>x is greater than 0</p>
                  </div>
              </ng-template>
              ```
    6. `@HostBinding`
        - Use it to bind with a certain property, e.g.
            - `@HostBinding('style.backgroundColor') backgroundColor = 'green'`
            - `@HostBinding('class.open') isOpen = true`

5. `[ngSwitch]`
    - ```xml
      <div [ngSwitch]="myValue">
          <p *ngSwitchCase="Yes">Yes, agreed.</p>
          <p *ngSwitchCase="No">No, disagreed.</p>
          <p *ngSwitchDefault>Can't say.</p>
      </div>
      ```

### Binding

1. Allow external components to "send" data
    - `@Input()`
    - Or binding through alias - `@Input('propertyName')`
2. Local reference
    - Used to pass data from HTML to TS
    - It passes the HTML Element itself (real reference)
    - Visible within the whole HTML Template
    - `<input type="text" #myHTMLReference>`
3. `@ViewChild()`
    - Used to pass data from HTML to TS
    - It passes `ElementRef`
        - Use `.nativeElement` to reference "real" element
    - **You shouldn't change element using this way, only get values**
        - This is discouraged way of modifying DOM
    - If you want to use it in `ngOnInit()` add `{ static: true }`
        - `@ViewChild('localReference', { static: true })`
    - You can reference the first occurrence of a given type
        - `@ViewChild(MyComponent)`
4. `<ng-content></ng-content>`
    - Directive used to include all HTML found within this tag
        - By default all HTML within Component HTML tags is lost
5. Lifecycle Hooks
    - `ngOnChanges` - after on bound input property change (`@Input`s)
        - It receives a `SimpleChanges` object
    - `ngOnInit` - Component is initialized (it is not not yet added to DOM)
        - Run after constructor
    - `ngDoCheck` - runs whenever Angular change detection runs, e.g. button clicked
    - `ngAfterContentInit` - whenever `<ng-content>` was projected into the View
    - `ngAfterContentChecked` - every time projected content was checked
    - `ngAfterViewInit` - after Component's View and child Views was initialized (rendered)
    - `ngAfterViewCheck` - every time Component's View and child Views was checked
    - `ngOnDestroy` - right before Component will be destroyed
6. `@ContentChild()`
    - Used to pass data from HTML to child Component's TS
    - If you want to use it in `ngAfterContentInit()` add `{ static: true }`
        - `@ContentChild('contentReference', { static: true })`

## How it works

1. Angular actually replaces Component tags like `<app-root></app-root>` with HTML defined in corresponding `.html` files
2. Angular is for creating SPAs - Single Page Applications
    - Even if we have Routing, etc. it's still an SPA
    - It is because there's only one `index.html`
3. Angular CLI injects into `<script>` tag code that starts Angular
4. The first code that gets executed is `main.ts` file
5. By default, directories aren't scanned, so you have to specify Components in `app.module.ts` in `@NgModule` in `declarations` property
6. **TL;DR is that Angular changes DOM (HTML) at runtime**
7. How Angular handles CSSes
    - It adds a certain unique property to all HTML elements in the given component and applies styles only on elements with matching property, e.g.
        - `<p _ngcontent-ejo-1>This text should be red</p>`
        - `p[_ngcontent-ejo-1] { font-color: red; }`
8. View Encapsulation
    - There are 3 types:
        - `None` - don't encapsulate CSS, so it will be applies globally (se even in parent Components)
        - `Native` (ShadowDOM) - encapsulates CSS natively, but only in browsers which support it
        - `Emulated` - like real ShadowDOM, but it's emulated, so all browsers will handle it properly
    - `@Component({ encapsulation: ViewEncapsulation.None })`

## Definitions

1. Decorator
    - `@Something` <- this is Decorator
    - Java Annotations are TypeScript Decorators

## Various

### Various

1. Inline HTML/CSS for Component
    - You can inline define HTML template in `@Component` Decorator
        - instead of `templateUrl` property, use just `template`
        - instead of `stylesUrl`, use `styles`
2. `innerText` ~ `{{ }}`
    - Both these expressions are equivalent:
        - `<p [innerText]="myValue"></p>`
        - `<p>{{ myValue }}</p>`
3. Shortcut for defining class fields
    - Put them into constructor like
        - `constructor(public field: string, public anotherField: int)`

### Emmet

1. Emmet
    - It's IDE plugin, which helps to work with HTML, CSS, JSX by expanding abbreviations
    - e.g. `app-component`, `Tab` becomes `<app-component></app-component>`
2. Create `div` with given `class`
    - creates `div` with given `class`
    - `.container` -> `<div class="container"></div>`
3. Create nested HTML
    - `.row>.col-xs-12` -> `<div class="row"><div class="col-xs-12"></div></div>`

### The rest

## Bootstrap

1. Create button group
    - `<div class="btn-group"></div>`

## Testing

Running tests on WSL2 requires to handle Chrome executable.  
Therefore working with them is more straightforward on host system.

1. Run tests
    - Build app in watch mode, launch Karma test runner
    - `ng test`
2. Customize Karma test runner
    - Create `karma.conf.js`, update `angular.json`
    - `ng generate config karma`
3. Run tests in CI/CD
    - `ng test --no-watch --no-progress --browsers=ChromeHeadless`
4. Generate Coverage Report
    - `ng test --no-watch --code-coverage`
5. Some ways of injecting dependencies
    1. Just use real production service
        - `new SubjectUnderTest(new ProdService())`
    2. Use fake service
        - `new SubjectUnderTest(new FakeService())`
    3. Use fake object
        - `new SubjectUnderTest({ someFunction: () => 'fake value' } as ProdService)`
    4. Use Spy
        - ```js
          const serviceSpy = jasmine.createSpyObj("ProdService", [ 'someFunction' ]);
          const stubValue = "stub value";
          serviceSpy.someFunction.and.returnValue(stubValue);
          new SubjectUnderTest(serviceSpy);
          ```

### `TestBed`

1. `TestBed` creates a dynamically-constructed Angular test module that emulates an Angular `@NgModule`.
2. `TestBed.configureTestingModule()` method takes a metadata object that can have most of the properties of an `@NgModule`.
3. When you want to test a Service, use `providers` metadata property and specify there other Services you want to mock.
    - `TestBed.configureTestingModule({ providers: [ MyService, { provide: OtherService, useValue: spy } ] });`
    - Or if using real class, instead of `useValue`, use: `useClass: TestOtherService`
4. Inject it then using `const service = TestBed.inject(MyService)`
5. Example

    - ```js
      let myService: MyService;
      let otherServiceSpy: jasmine.SpyObj<OtherService>;

      beforeEach(() => (
        const spy = jasmine.createSpyObj('OtherService', ['someFunction']);
        TestBed.configureTestingModule({ providers: [ MyService, { provide: OtherService, useValue: spy } ]});
      ));

      myService = TestBed.inject(MyService);
      otherServiceSpy = TestBed.inject(OtherService) as jasmine SpyObj<OtherService>;
      ```

### Testing HTTP Services

1. ❗ Always provide both `next` and `error` callbacks for `Observable`s.  
   Otherwise you may encounter other tests failing in random places!
    - It is because without specifying `error`, you end up with an asynchronous uncaught observable error.
2. Example of HTTP test

    - ```js
      let httpClientSpy: jasmine.SpyObj<HttpClient>;
      let myService: MyService;

      beforeEach(() => {
        httpClientSpy = jasmine.createObjSpy('HttpClient', ['get']);
        myService = new MyService(httpClientSpy);
      });

      it('should return expected response', (done: DoneFn) => {
        const expectedValue = 'correct value';

        httpClientSpy.get.and.returnValue(asyncData(expectedValue));

        myService.someFunction().subscribe({
            next: (returnedValue) => {
                expect(returnedValue).toEqual(expectedValue);
                done();
            },
            error: done.fail,
        });
        expect(httpClientSpy.get.calls.count()).toBe(1);
      });
      ```

3. `HttpClientTestingModule`
    - Used for complex interactions
    - It's covered in [HttpGuide](https://angular.io/guide/http-test-requests)

### Testing Components

1. Remember to manually call [lifecycle hook methods](https://angular.io/guide/lifecycle-hooks) like `ngOnInit` (just as Angular would do)

#### DOM Testing

1. Component is more than just a class. It interacts with DOM and other Components.
    - Therefore tests covering only a class won't tell if Component renders, interacts with user or interact with other (e.g. parent or child) Components properly.
    - You need to examine DOM and simulate user interactions to be able to confirm Component works as intended.
2. When function call is asynchronous, you can use `waitForAsync()`
    - ```js
      beforeEach(waitForAsync(() => {
        TestBed.configureTestingModule({ imports: [ BannerComponent ]}).compileComponents();
      }));
      ```
3. Basic Component test assertion
    - Component can be created
    - `expect(component).toBeDefined();`
4. `createComponent()`
    - `TestBed.createComponent(MyComponent)` creates an instance of `MyComponent`, adds it to the DOM and returns a `ComponentFixture`
5. `ComponentFixture`
    - It's a harness for interacting with the created Component and its corresponding element
    - ```js
      const componentFixture = TestBed.createComponent(MyComponent);
      const component = componentFixture.componentInstance;
      expect(component).toBeDefined();
      ```
6. ❗ Don't reconfigure `TestBed` after calling `createComponent()`
    - `createComponent()` freezes the current `TestBed` definition, which makes it closed to further modifications
7. `NativeElement`
    - It's `any` type, as at a compile time it's unknown what type it is or even if it's an `HTMLElement`
        - Tests may be run on a non-browser platform such as WebWorker or any other that doesn't have DOM or where DOM-emulation doesn't support full `HTMLElement` API
    - In standard browser environment `nativeElement` will always be an `HTMLElement` (or one of it's derived classes)
    - You can use standard HTML API then, e.g. `querySelector()`
        - ```js
          const bannerElement: HTMLElement = componentFixture.nativeElement;
          const paragraph = bannerElement.querySelector('p')!;
          expect(p.textContext).toEqual('Hello World');
          ```
    - Under the hood it's actually `fixture.debugElement.nativeElement`
8. `DebugElement`
    - An abstraction to work safely across all platforms
    - Angular creates a `DebugElement` tree which wraps `NativeElement`s for the running platform
    - `DebugElement` contains methods and properties useful in testing
9. Example of testing
